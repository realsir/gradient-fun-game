<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GradGame</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: monospace;
      min-height: 100vh;
      background: #ededed;
      overflow: hidden;
      position: relative; 
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #bgtext {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      font-size: 22px;
      line-height: 29px;
      color: #0b8a00;
      opacity: 0.15;
      white-space: pre;
      pointer-events: none;
      z-index: 0;
      user-select: none;
      background: none;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      z-index: 3;
      background: rgba(255,255,255,0.82);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .overlay-block {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 4px 22px #3333;
      padding: 45px 44px 32px 44px;
      text-align: center;
      font-size: 22px;
      color: #181818;
      min-width: 300px;
      max-width: 95vw;
    }
    .big-btn {
      display: inline-block;
      margin-top: 18px;
      padding: 14px 70px;
      font-size: 24px;
      background: #222;
      color: #fafafa;
      border: none;
      border-radius: 7px;
      letter-spacing: 0.1em;
      box-shadow: 0 2px 18px #aaa2;
      cursor: pointer;
      transition: background 0.2s;
      font-family: monospace;
      font-weight: 700;
    }
    .big-btn:hover, .big-btn:focus {
      background: #111;
    }
    .btn-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .mode-desc {
      margin-top: 10px;
      color: #555;
      font-size: 18px;
      line-height: 1.5;
      max-width: 400px;
    }
    #ui { 
      z-index: 1;
      position: relative;
      align-items: center;
      display: flex;
      flex-direction: column;
      margin-top: 10px;
    }
    .ui-top-row {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 10px;
    }
    #stats {
      font-size: 20px;
      background: #fffde6ee;
      padding: 5px 35px;
      border-radius: 10px;
      color: #1a1a1a;
      white-space: nowrap;
    }
    #menuBtn {
      padding: 5px 25px;
      font-size: 18px;
      background: #fffde6ee;
      color: #1a1a1a;
      border: 2px solid #ddd;
      border-radius: 10px;
      cursor: pointer;
      font-family: monospace;
      font-weight: 600;
      transition: all 0.2s;
      white-space: nowrap;
    }
    #menuBtn:hover {
      background: #fff;
      border-color: #bbb;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      height: 480px;
      margin-bottom: 4px;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(30, 24px);
      grid-template-rows: repeat(20, 24px);
      gap: 0;
      background: #fff;
      border: 2px solid #666;
      z-index: 1;
      position: absolute;
      top: 0;
      left: 0;
    }
    .cell {
      width: 24px; height: 24px;
      display: flex; align-items: center; justify-content: center;
      font-size: 21px;
      background: #fafafa;
      border: 1px solid #bbb;
      box-sizing: border-box;
      user-select: none;
      z-index: 2;
    }
    .black { color: #111 !important; font-weight: bold; }
    .hide { display: none !important; }

    .float-text {
      position: absolute;
      font-size: 18px;
      color: #0b8a00;
      font-weight: 700;
      pointer-events: none;
      z-index: 6;
      animation: floatUp 1.2s ease-out forwards;
    }
    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
      50% {
        transform: translate(-50%, -20px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50px) scale(0.8);
      }
    }
    #pauseOverlay {
      position: fixed;
      z-index: 10;
      background: rgba(11, 138, 0, 0.7);
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: #fff;
      font-weight: 700;
      user-select: none;
      font-family: monospace;
      letter-spacing: 0.2em;
    }
  </style>
</head>
<body>
  <div id="bgtext"></div>
  
  <div id="welcome" class="overlay">
    <div class="overlay-block">
      <div style="font-size:25px;font-weight:700;margin-bottom:17px;">./ Welcome to "GradGame"</div>
      
      <div style="margin-bottom: 25px;">
        <div>Choose your game mode:</div>
      </div>
      
      <div class="btn-row">
        <div style="text-align: center;">
          <button class="big-btn" id="gradBtn">./ GRAD MODE+</button>
          <div class="mode-desc">
            You have a single goal – collect the combinations as quickly as you can!<br><br>
            1. "–" these are now your advantages.<br>
            2. "," and these are your opponents, who are best left alone<br>
            3. "./" for each correctly completed combination, your current time increases by +2 sec.<br>
            4. "*" bonuses give +5 points and +3 sec.<br>
            5. "SPACE" for pause/unpause.
          </div>
        </div>
        
        <div style="text-align: center;">
          <button class="big-btn" id="classicBtn">./ GRAD CLASSIC</button>
          <div class="mode-desc">
            Only you (.) and the opponent (/) playing the classic way.<br><br>
            1. "SPACE" for pause/unpause.
          </div>
        </div>
        
        <div style="text-align: center;">
          <button class="big-btn" id="survivalBtn">./ GRAD SURVIVAL</button>
          <div class="mode-desc">
            Survive 30 seconds against 15 moving enemies (/).<br><br>
            1. Enemies chase you every second. Game Over if ANY enemy gets adjacent!<br>
            2. "SPACE" for pause/unpause.
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="gameover" class="overlay hide">
    <div class="overlay-block" id="overmsg">
      <div style="font-size:23px;margin-bottom:14px;" id="gameOverMsg">Time is up!</div>
      Your score: <span id="finalscore"></span><br>
      High score: <span id="highscore"></span>
      <br />
      <div class="btn-row">
        <button class="big-btn" id="restartBtn">./ Restart</button>
        <button class="big-btn" id="menuBtnGameover">./ Menu</button>
      </div>
    </div>
  </div>
  
  <div id="victory" class="overlay hide">
    <div class="overlay-block" id="victorymsg">
      <div style="font-size:23px;margin-bottom:14px;color:#0b8a00;">./ YOU WIN!</div>
      Survival time: <span id="victoryscore"></span><br>
      Best survival: <span id="victoryhighscore"></span>
      <br />
      <div class="btn-row">
        <button class="big-btn" id="restartBtnVictory">./ Restart</button>
        <button class="big-btn" id="menuBtnVictory">./ Menu</button>
      </div>
    </div>
  </div>
  
  <div id="pauseOverlay">./ PAUSED</div>
  
  <div id="ui" class="hide">
    <div class="ui-top-row">
      <button id="menuBtn">./ Menu</button>
      <div id="stats">
        Score: <span id="score">0</span> | Time: <span id="timer">30</span> sec | High score: <span id="highscoreTop">0</span>
      </div>
    </div>
    <div id="gameContainer">
      <div id="game"></div>
    </div>
  </div>

  <script>
    function fillBgText() {
      let rows = Math.ceil(window.innerHeight / 29) + 2;
      let cols = Math.ceil(window.innerWidth / 18);
      let str = '';
      let line = '';
      let pattern = './ GradGame ';
      for(let i = 0; i < Math.ceil(cols * 1.5); i++) line += pattern;
      for(let i = 0; i < rows; i++) str += line.substr(0, cols*9) + '\n'; 
      document.getElementById("bgtext").textContent = str;
    }
    window.addEventListener('resize', fillBgText);
    fillBgText();

    const width = 30, height = 20, initialTime = 30;
    let player, goal, score, time, interval, running, gameStarted = false, paused = false, currentMode = '';
    let enemies = [], survivalEnemiesMoveInterval;

    const gameContainer = document.getElementById('gameContainer');
    const gameDiv = document.getElementById('game');
    const scoreSpan = document.getElementById('score');
    const timerSpan = document.getElementById('timer');
    const uiDiv = document.getElementById('ui');
    const welcomeDiv = document.getElementById('welcome');
    const gameoverDiv = document.getElementById('gameover');
    const victoryDiv = document.getElementById('victory');
    const finalscore = document.getElementById('finalscore');
    const victoryscore = document.getElementById('victoryscore');
    const highscoreSpan = document.getElementById('highscore');
    const highscoreTop = document.getElementById('highscoreTop');
    const victoryhighscore = document.getElementById('victoryhighscore');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const menuBtn = document.getElementById('menuBtn');
    const menuBtnGameover = document.getElementById('menuBtnGameover');
    const menuBtnVictory = document.getElementById('menuBtnVictory');
    const gradBtn = document.getElementById('gradBtn');
    const classicBtn = document.getElementById('classicBtn');
    const survivalBtn = document.getElementById('survivalBtn');
    const restartBtn = document.getElementById('restartBtn');
    const restartBtnVictory = document.getElementById('restartBtnVictory');
    const gameOverMsg = document.getElementById('gameOverMsg');

    let obstacles = [], powerups = [], staticEnemies = [];

    function showMenu() {
      gameStarted = false;
      running = false;
      paused = false;
      clearInterval(interval);
      clearInterval(survivalEnemiesMoveInterval);
      uiDiv.classList.add('hide');
      welcomeDiv.classList.remove('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';
      gameDiv.innerHTML = '';
    }

    function isObstacle(x, y) {
      return obstacles.some(o => o.x === x && o.y === y);
    }

    function isStaticEnemy(x, y) {
      return staticEnemies.some(e => e.x === x && e.y === y);
    }

    function isPowerup(x, y) {
      return powerups.some(p => p.x === x && p.y === y);
    }

    function isSurvivalEnemy(x, y) {
      return enemies.some(e => e.x === x && e.y === y);
    }

    function isPositionOccupied(x, y) {
      return (x === player.x && y === player.y) || isSurvivalEnemy(x, y);
    }

    
    function isEnemyAdjacentToPlayer() {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue; 
          
          let checkX = (player.x + dx + width) % width;
          let checkY = (player.y + dy + height) % height;
          
          if (isSurvivalEnemy(checkX, checkY)) {
            return true;
          }
        }
      }
      return false;
    }

    function generateSurvivalEnemies() {
      enemies = [];
      let tries = 0;
      while (enemies.length < 15 && tries < 1000) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if (isPositionOccupied(ex, ey) || enemies.some(e => e.x === ex && e.y === ey)) continue;
        enemies.push({x: ex, y: ey});
      }
    }

    function generateFullMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];
      
      const MIN_OBS = 20, MAX_OBS = 30;
      const MIN_ENEMIES = 3, MAX_ENEMIES = 5;

      const obsCount = Math.floor(Math.random() * (MAX_OBS - MIN_OBS + 1)) + MIN_OBS;
      let tries = 0;
      while (obstacles.length < obsCount && tries < 1000) {
        tries++;
        const ox = Math.floor(Math.random() * width);
        const oy = Math.floor(Math.random() * height);
        if (isNearGoal(ox, oy) || (ox === player.x && oy === player.y) || (ox === goal.x && oy === goal.y)) continue;
        obstacles.push({x: ox, y: oy});
      }

      const enemyCount = Math.floor(Math.random() * (MAX_ENEMIES - MIN_ENEMIES + 1)) + MIN_ENEMIES;
      tries = 0;
      while (staticEnemies.length < enemyCount && tries < 500) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if (
          (ex === player.x && ey === player.y) ||
          (ex === goal.x && ey === goal.y) ||
          isObstacle(ex, ey) ||
          isNearGoal(ex, ey) ||
          staticEnemies.some(e => e.x === ex && e.y === ey)
        ) continue;
        staticEnemies.push({x: ex, y: ey});
      }

      const powerupCount = 3;
      tries = 0;
      while (powerups.length < powerupCount && tries < 1000) {
        tries++;
        const px = Math.floor(Math.random() * width);
        const py = Math.floor(Math.random() * height);
        if (
          isNearGoal(px, py) || 
          (px === player.x && py === player.y) || 
          (px === goal.x && py === goal.y) ||
          isObstacle(px, py) ||
          isStaticEnemy(px, py)
        ) continue;
        powerups.push({x: px, y: py});
      }
    }

    function moveSurvivalEnemies() {
      
      if (isEnemyAdjacentToPlayer()) {
        gameOver("Enemy too close!");
        return;
      }

      let movedEnemies = [];
      enemies.forEach(enemy => {
        let bestDx = 0, bestDy = 0, bestDist = Infinity;
        
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            let nx = (enemy.x + dx + width) % width;
            let ny = (enemy.y + dy + height) % height;
            
            let occupied = isPositionOccupied(nx, ny) || 
                          movedEnemies.some(m => m.x === nx && m.y === ny);
            
            let dist = Math.abs(nx - player.x) + Math.abs(ny - player.y);
            if (!occupied && dist < bestDist) {
              bestDist = dist;
              bestDx = dx;
              bestDy = dy;
            }
          }
        }
        
        let newX = (enemy.x + bestDx + width) % width;
        let newY = (enemy.y + bestDy + height) % height;
        enemy.x = newX;
        enemy.y = newY;
        movedEnemies.push({x: newX, y: newY});
      });
      
      
      if (isEnemyAdjacentToPlayer()) {
        gameOver("Enemy too close!");
      } else {
        drawGrid();
      }
    }

    function generateClassicMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];
    }

    function isNearGoal(x, y) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (goal.x + dx === x && goal.y + dy === y) return true;
        }
      }
      return false;
    }

    function drawGrid() {
      gameDiv.innerHTML = '';
      for(let y = 0; y < height; y++) {
        for(let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          if (player.x === x && player.y === y) {
            cell.innerHTML = '<span class="black">.</span>';
          } else if (currentMode === 'grad' && goal.x === x && goal.y === y) {
            cell.innerHTML = '<span class="black">/</span>';
          } else if (currentMode === 'classic' && goal.x === x && goal.y === y) {
            cell.innerHTML = '<span class="black">/</span>';
          } else if (currentMode === 'survival' && isSurvivalEnemy(x, y)) {
            cell.innerHTML = '<span class="black">/</span>';
          } else if (currentMode === 'grad' && isStaticEnemy(x, y)) {
            cell.innerHTML = '<span class="black">,</span>';
          } else if (currentMode === 'grad' && isObstacle(x, y)) {
            cell.innerHTML = '<span class="black">-</span>';
          } else if (currentMode === 'grad' && isPowerup(x, y)) {
            cell.innerHTML = '<span class="black">*</span>';
          } else {
            cell.innerHTML = '&nbsp;';
          }
          gameDiv.appendChild(cell);
        }
      }
    }

    function placeGoal() {
      do {
        goal.x = Math.floor(Math.random() * width);
        goal.y = Math.floor(Math.random() * height);
      } while (
        (goal.x === player.x && goal.y === player.y) ||
        (goal.x === 0) ||
        (currentMode === 'grad' && (isObstacle(goal.x, goal.y) || isStaticEnemy(goal.x, goal.y) || isPowerup(goal.x, goal.y)))
      );
    }

    function showPlusTime(x, y, text) {
      const float = document.createElement('div');
      float.className = 'float-text';
      float.textContent = text;
      const cellSize = 24;
      const offsetX = x * cellSize + cellSize / 2;
      const offsetY = y * cellSize + cellSize / 2;
      float.style.left = offsetX + 'px';
      float.style.top = offsetY + 'px';
      gameContainer.appendChild(float);
      setTimeout(() => {
        if (float.parentNode) float.parentNode.removeChild(float);
      }, 1300);
    }

    function addTime(seconds) {
      time += seconds;
      timerSpan.textContent = time;
    }

    function gameOver(msg = "Time is up!") {
      gameStarted = false;
      running = false;
      clearInterval(survivalEnemiesMoveInterval);
      const highscoreKey = currentMode === 'grad' ? 'gradHighScore' : 
                          currentMode === 'classic' ? 'classicHighScore' : 'survivalHighScore';
      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }
      highscoreSpan.textContent = highscore;
      highscoreTop.textContent = highscore;
      gameOverMsg.textContent = msg;
      finalscore.textContent = score;
      uiDiv.classList.add('hide');
      gameoverDiv.classList.remove('hide');
    }

    function victory() {
      gameStarted = false;
      running = false;
      clearInterval(survivalEnemiesMoveInterval);
      score = 100;
      const highscoreKey = 'survivalHighScore';
      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }
      victoryscore.textContent = score;
      victoryhighscore.textContent = highscore;
      highscoreTop.textContent = highscore;
      uiDiv.classList.add('hide');
      victoryDiv.classList.remove('hide');
    }

    function movePlayer(dx, dy) {
      if (!running || !gameStarted || paused) return;

      let newX = (player.x + dx + width) % width;
      let newY = (player.y + dy + height) % height;

      
      if (currentMode === 'survival' && isSurvivalEnemy(newX, newY)) {
        gameOver("Enemy too close!");
        return;
      }

      
      if (currentMode === 'grad') {
        if (isObstacle(newX, newY)) return;
        if (isStaticEnemy(newX, newY)) {
          gameOver("You bumped into an opponent (,)");
          return;
        }
        if (isPowerup(newX, newY)) {
          score += 5;
          addTime(3);
          showPlusTime(newX, newY, './ +3 sec +5 points');
          const idx = powerups.findIndex(p => p.x === newX && p.y === newY);
          if (idx !== -1) powerups.splice(idx, 1);
          player.x = newX;
          player.y = newY;
          scoreSpan.textContent = score;
          drawGrid();
          return;
        }
      }

      
      if (currentMode !== 'survival' && newX === goal.x && newY === goal.y && dx === 1) {
        player.x = newX;
        player.y = newY;
        score++;
        scoreSpan.textContent = score;
        addTime(2);
        showPlusTime(newX, newY, './ +2 sec');
        placeGoal();
        if (currentMode === 'grad') generateFullMode();
        drawGrid();
      } else if (!(newX === goal.x && newY === goal.y)) {
        player.x = newX;
        player.y = newY;
      }
      drawGrid();
    }

    function startTimer() {
      clearInterval(interval);
      timerSpan.textContent = time;
      interval = setInterval(() => {
        if (!paused) {
          time--;
          if (time <= 0) {
            time = 0;
            timerSpan.textContent = 0;
            clearInterval(interval);
            running = false;
            if (currentMode === 'survival') {
              setTimeout(victory, 300);
            } else {
              setTimeout(gameOver, 300);
            }
          } else {
            timerSpan.textContent = time;
          }
        }
      }, 1000);
    }

    function startGame(mode) {
      currentMode = mode;
      player = {x: 15, y: 10};
      goal = {x: 0, y: 0};
      score = 0;
      time = initialTime;
      running = true;
      gameStarted = true;
      paused = false;
      
      scoreSpan.textContent = '0';
      timerSpan.textContent = initialTime;
      
      if (mode === 'survival') {
        generateSurvivalEnemies();
        clearInterval(survivalEnemiesMoveInterval);
        survivalEnemiesMoveInterval = setInterval(() => {
          if (running && !paused) {
            moveSurvivalEnemies();
          }
        }, 1000);
      } else {
        clearInterval(survivalEnemiesMoveInterval);
        placeGoal();
        if (mode === 'grad') {
          generateFullMode();
        } else {
          generateClassicMode();
        }
      }
      
      drawGrid();
      uiDiv.classList.remove('hide');
      welcomeDiv.classList.add('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';
      
      const highscoreKey = mode === 'grad' ? 'gradHighScore' : 
                          mode === 'classic' ? 'classicHighScore' : 'survivalHighScore';
      highscoreTop.textContent = localStorage.getItem(highscoreKey) || 0;
      
      startTimer();
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
      }
      if (e.code === 'Space' && gameStarted && running) {
        paused = !paused;
        pauseOverlay.style.display = paused ? 'flex' : 'none';
        return;
      }
      if (!running || !gameStarted || paused) return;
      if (['ArrowUp','KeyW','KeyЦ'].includes(e.code)) movePlayer(0, -1);
      if (['ArrowDown','KeyS','KeyЫ'].includes(e.code)) movePlayer(0, 1);
      if (['ArrowLeft','KeyA','KeyФ'].includes(e.code)) movePlayer(-1, 0);
      if (['ArrowRight','KeyD','KeyВ'].includes(e.code)) movePlayer(1, 0);
    });

    gradBtn.onclick = () => startGame('grad');
    classicBtn.onclick = () => startGame('classic');
    survivalBtn.onclick = () => startGame('survival');
    restartBtn.onclick = () => startGame(currentMode);
    restartBtnVictory.onclick = () => startGame(currentMode);
    menuBtn.onclick = showMenu;
    menuBtnGameover.onclick = showMenu;
    menuBtnVictory.onclick = showMenu;
  </script>
</body>
</html>
