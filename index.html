<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GradGame</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; }
    body {
      font-family: monospace;
      min-height: 100vh;
      background: #ededed;
      overflow: hidden;
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #bgtext {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      font-size: 22px;
      line-height: 29px;
      color: #0b8a00;
      opacity: 0.15;
      white-space: pre;
      pointer-events: none;
      z-index: 0;
      user-select: none;
      background: none;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      z-index: 3;
      background: rgba(255,255,255,0.82);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .overlay-block {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 4px 22px #3333;
      padding: 30px 32px;
      text-align: center;
      font-size: 20px;
      color: #181818;
      min-width: 320px;
      max-width: 95vw;
      max-height: 85vh;
      overflow-y: auto;
    }
    .big-btn {
      display: inline-block;
      margin: 8px 0;
      padding: 12px 45px;
      font-size: 20px;
      background: #222;
      color: #fafafa;
      border: none;
      border-radius: 7px;
      letter-spacing: 0.1em;
      box-shadow: 0 2px 18px #aaa2;
      cursor: pointer;
      transition: background 0.2s;
      font-family: monospace;
      font-weight: 700;
      width: 100%;
      max-width: 280px;
    }
    .big-btn:hover, .big-btn:focus { background: #111; }
    .mode-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .mode-card {
      background: rgba(255,255,255,0.7);
      border-radius: 12px;
      padding: 20px 15px;
      border: 2px solid #e0e0e0;
      transition: all 0.2s;
    }
    .mode-card:hover {
      border-color: #0b8a00;
      box-shadow: 0 4px 15px #0b8a0080;
    }
    .mode-desc {
      color: #555;
      font-size: 15px;
      line-height: 1.4;
      margin: 0;
    }
    #ui {
      z-index: 1;
      position: relative;
      align-items: center;
      display: flex;
      flex-direction: column;
      margin-top: 10px;
    }
    .ui-top-row {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 10px;
    }
    #stats {
      font-size: 20px;
      background: #fffde6ee;
      padding: 5px 35px;
      border-radius: 10px;
      color: #1a1a1a;
      white-space: nowrap;
    }
    #menuBtn {
      padding: 5px 25px;
      font-size: 18px;
      background: #fffde6ee;
      color: #1a1a1a;
      border: 2px solid #ddd;
      border-radius: 10px;
      cursor: pointer;
      font-family: monospace;
      font-weight: 600;
      transition: all 0.2s;
      white-space: nowrap;
    }
    #menuBtn:hover { background: #fff; border-color: #bbb; }
    #gameContainer { position: relative; width: 720px; height: 480px; margin-bottom: 4px; }
    #game {
      display: grid;
      grid-template-columns: repeat(30, 24px);
      grid-template-rows: repeat(20, 24px);
      gap: 0;
      background: #fff;
      border: 2px solid #666;
      z-index: 1;
      position: absolute;
      top: 0;
      left: 0;
    }
    .cell {
      width: 24px; height: 24px;
      display: flex; align-items: center; justify-content: center;
      font-size: 21px;
      background: #fafafa;
      border: 1px solid #bbb;
      box-sizing: border-box;
      user-select: none;
      z-index: 2;
    }
    .black { color: #111 !important; font-weight: bold; }
    .warn { color: #b88600 !important; font-weight: 900; }
    .boom { color: #b80000 !important; font-weight: 900; }
    .hide { display: none !important; }

    .float-text {
      position: absolute;
      font-size: 18px;
      color: #0b8a00;
      font-weight: 700;
      pointer-events: none;
      z-index: 6;
      animation: floatUp 1.2s ease-out forwards;
    }
    @keyframes floatUp {
      0% { opacity: 1; transform: translate(-50%, 0) scale(1); }
      50% { transform: translate(-50%, -20px) scale(1.2); }
      100% { opacity: 0; transform: translate(-50%, -50px) scale(0.8); }
    }
    #pauseOverlay {
      position: fixed;
      z-index: 10;
      background: rgba(11, 138, 0, 0.7);
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: #fff;
      font-weight: 700;
      user-select: none;
      font-family: monospace;
      letter-spacing: 0.2em;
    }
  </style>
</head>
<body>
  <div id="bgtext"></div>

  <div id="welcome" class="overlay">
    <div class="overlay-block">
      <div style="font-size:25px;font-weight:700;margin-bottom:17px;">./ Welcome to "GradGame"</div>
      <div style="margin-bottom: 25px;"><div>Choose your game mode:</div></div>

      <div class="mode-grid">
        <div class="mode-card">
          <button class="big-btn" id="gradBtn">./ GRAD MODE+</button>
          <div class="mode-desc">
            Single goal – collect combinations quickly!<br>
            • "-" obstacles<br>
            • "," opponents (avoid)<br>
            • "./" +2 sec per combo<br>
            • "*" +5 points +3 sec<br>
            • SPACE pause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="classicBtn">./ GRAD CLASSIC</button>
          <div class="mode-desc">
            You (.) vs goal (/).<br>
            • Collect only as "./" (from right)<br>
            • You cannot pass through "/"<br>
            • SPACE pause/unpause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="mazeBtn">./ GRAD MAZE</button>
          <div class="mode-desc">
            Navigate maze corridors to reach (/).<br>
            • "#" walls block movement<br>
            • Reach goal ANY side: +20 sec, new maze!<br>
            • 60 sec start time<br>
            • SPACE pause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="survivalBtn">./ GRAD SURVIVAL</button>
          <div class="mode-desc">
            Survive 30 sec vs 15 enemies (/).<br>
            • Enemies chase every second<br>
            • Game Over if adjacent!<br>
            • SPACE pause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="dangerBtn">./ GRAD DANGER ZONE</button>
          <div class="mode-desc">
            Telegraph blasts (anti-camping).<br>
            • Every 2 sec spawns 2–4 "x"<br>
            • After ~1.2 sec -> "X" blast (fatal)<br>
            • Blast lasts ~0.7 sec<br>
            • SPACE pause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="snakeBtn">./ GRAD SNAKE</button>
          <div class="mode-desc">
            Classic snake on the same field.<br>
            • Always moving as "./"<br>
            • Eat "./" to grow (adds "/" segments)<br>
            • One point at a time<br>
            • Wall/self hit = lose<br>
            • No timer<br>
            • SPACE pause
          </div>
        </div>

      </div>
    </div>
  </div>

  <div id="gameover" class="overlay hide">
    <div class="overlay-block" id="overmsg">
      <div style="font-size:23px;margin-bottom:14px;" id="gameOverMsg">Time is up!</div>
      Your score: <span id="finalscore"></span><br>
      High score: <span id="highscore"></span>
      <br />
      <div style="display:flex;gap:15px;justify-content:center;margin-top:20px;">
        <button class="big-btn" id="restartBtn" style="width:auto;">./ Restart</button>
        <button class="big-btn" id="menuBtnGameover" style="width:auto;">./ Menu</button>
      </div>
    </div>
  </div>

  <div id="victory" class="overlay hide">
    <div class="overlay-block" id="victorymsg">
      <div style="font-size:23px;margin-bottom:14px;color:#0b8a00;">./ YOU WIN!</div>
      Survival time: <span id="victoryscore"></span><br>
      Best survival: <span id="victoryhighscore"></span>
      <br />
      <div style="display:flex;gap:15px;justify-content:center;margin-top:20px;">
        <button class="big-btn" id="restartBtnVictory" style="width:auto;">./ Restart</button>
        <button class="big-btn" id="menuBtnVictory" style="width:auto;">./ Menu</button>
      </div>
    </div>
  </div>

  <div id="pauseOverlay">./ PAUSED</div>

  <div id="ui" class="hide">
    <div class="ui-top-row">
      <button id="menuBtn">./ Menu</button>
      <div id="stats">
        Score: <span id="score">0</span> | Time: <span id="timer">60</span> sec | High score: <span id="highscoreTop">0</span>
      </div>
    </div>
    <div id="gameContainer"><div id="game"></div></div>
  </div>

  <script>
    function fillBgText() {
      let rows = Math.ceil(window.innerHeight / 29) + 2;
      let cols = Math.ceil(window.innerWidth / 18);
      let str = '';
      let line = '';
      let pattern = './ GradGame ';
      for (let i = 0; i < Math.ceil(cols * 1.5); i++) line += pattern;
      for (let i = 0; i < rows; i++) str += line.substr(0, cols * 9) + '\n';
      document.getElementById("bgtext").textContent = str;
    }
    window.addEventListener('resize', fillBgText);
    fillBgText();

    const width = 30, height = 20;

    let player, goal, score, time, interval, running, gameStarted = false, paused = false, currentMode = '';
    let enemies = [], survivalEnemiesMoveInterval;

    let obstacles = [], powerups = [], staticEnemies = [];
    let mazeGrid = [];

    let hazards = [];
    let hazardSpawnInterval, hazardTickInterval;

    let snake = [];
    let snakeDir = { dx: 1, dy: 0 };
    let snakeNextDir = { dx: 1, dy: 0 };
    let snakeTickInterval;

    const gameContainer = document.getElementById('gameContainer');
    const gameDiv = document.getElementById('game');
    const scoreSpan = document.getElementById('score');
    const timerSpan = document.getElementById('timer');
    const uiDiv = document.getElementById('ui');
    const welcomeDiv = document.getElementById('welcome');
    const gameoverDiv = document.getElementById('gameover');
    const victoryDiv = document.getElementById('victory');
    const finalscore = document.getElementById('finalscore');
    const victoryscore = document.getElementById('victoryscore');
    const highscoreSpan = document.getElementById('highscore');
    const highscoreTop = document.getElementById('highscoreTop');
    const victoryhighscore = document.getElementById('victoryhighscore');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const menuBtn = document.getElementById('menuBtn');

    const menuBtnGameover = document.getElementById('menuBtnGameover');
    const menuBtnVictory = document.getElementById('menuBtnVictory');

    const gradBtn = document.getElementById('gradBtn');
    const classicBtn = document.getElementById('classicBtn');
    const mazeBtn = document.getElementById('mazeBtn');
    const survivalBtn = document.getElementById('survivalBtn');
    const dangerBtn = document.getElementById('dangerBtn');
    const snakeBtn = document.getElementById('snakeBtn');

    const restartBtn = document.getElementById('restartBtn');
    const restartBtnVictory = document.getElementById('restartBtnVictory');
    const gameOverMsg = document.getElementById('gameOverMsg');

    function getInitialTime(mode) {
      if (mode === 'maze') return 60;
      return 30;
    }

    function clearAllIntervals() {
      clearInterval(interval);
      clearInterval(survivalEnemiesMoveInterval);
      clearInterval(hazardSpawnInterval);
      clearInterval(hazardTickInterval);
      clearInterval(snakeTickInterval); 
    }

    function showMenu() {
      gameStarted = false;
      running = false;
      paused = false;

      clearAllIntervals();

      uiDiv.classList.add('hide');
      welcomeDiv.classList.remove('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';
      gameDiv.innerHTML = '';

      hazards = [];
      enemies = [];
      obstacles = [];
      staticEnemies = [];
      powerups = [];
      mazeGrid = [];

      snake = [];
      snakeDir = { dx: 1, dy: 0 };
      snakeNextDir = { dx: 1, dy: 0 };
    }

    function showPlusTime(x, y, text) {
      const float = document.createElement('div');
      float.className = 'float-text';
      float.textContent = text;
      const cellSize = 24;
      const offsetX = x * cellSize + cellSize / 2;
      const offsetY = y * cellSize + cellSize / 2;
      float.style.left = offsetX + 'px';
      float.style.top = offsetY + 'px';
      gameContainer.appendChild(float);
      setTimeout(() => { if (float.parentNode) float.parentNode.removeChild(float); }, 1300);
    }

    function addTime(seconds) {
      time += seconds;
      timerSpan.textContent = time;
    }

    function isObstacle(x, y) { return obstacles.some(o => o.x === x && o.y === y); }
    function isStaticEnemy(x, y) { return staticEnemies.some(e => e.x === x && e.y === y); }
    function isPowerup(x, y) { return powerups.some(p => p.x === x && p.y === y); }
    function isSurvivalEnemy(x, y) { return enemies.some(e => e.x === x && e.y === y); }

    function isSnakeCell(x, y) { return snake.some(s => s.x === x && s.y === y); }
    function isSnakeHead(x, y) { return snake.length && snake[0].x === x && snake[0].y === y; }

    function isNearGoal(x, y) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (goal.x + dx === x && goal.y + dy === y) return true;
        }
      }
      return false;
    }

    function isEnemyAdjacentToPlayer() {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          let checkX = (player.x + dx + width) % width;
          let checkY = (player.y + dy + height) % height;
          if (isSurvivalEnemy(checkX, checkY)) return true;
        }
      }
      return false;
    }

    function generateSurvivalEnemies() {
      enemies = [];
      let tries = 0;
      while (enemies.length < 15 && tries < 1000) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if ((ex === player.x && ey === player.y) || enemies.some(e => e.x === ex && e.y === ey)) continue;
        enemies.push({ x: ex, y: ey });
      }
    }

    function moveSurvivalEnemies() {
      if (isEnemyAdjacentToPlayer()) {
        gameOver("Enemy too close!");
        return;
      }

      let movedEnemies = [];
      enemies.forEach(enemy => {
        let bestDx = 0, bestDy = 0, bestDist = Infinity;
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            let nx = (enemy.x + dx + width) % width;
            let ny = (enemy.y + dy + height) % height;

            let occupied =
              (nx === player.x && ny === player.y) ||
              enemies.some(e => e !== enemy && e.x === nx && e.y === ny) ||
              movedEnemies.some(m => m.x === nx && m.y === ny);

            let dist = Math.abs(nx - player.x) + Math.abs(ny - player.y);
            if (!occupied && dist < bestDist) {
              bestDist = dist;
              bestDx = dx;
              bestDy = dy;
            }
          }
        }
        enemy.x = (enemy.x + bestDx + width) % width;
        enemy.y = (enemy.y + bestDy + height) % height;
        movedEnemies.push({ x: enemy.x, y: enemy.y });
      });

      if (isEnemyAdjacentToPlayer()) gameOver("Enemy too close!");
      else drawGrid();
    }

    function generateClassicMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];
    }

    function generateFullMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];

      const MIN_OBS = 20, MAX_OBS = 30;
      const MIN_ENEMIES = 3, MAX_ENEMIES = 5;

      const obsCount = Math.floor(Math.random() * (MAX_OBS - MIN_OBS + 1)) + MIN_OBS;
      let tries = 0;
      while (obstacles.length < obsCount && tries < 1000) {
        tries++;
        const ox = Math.floor(Math.random() * width);
        const oy = Math.floor(Math.random() * height);
        if (isNearGoal(ox, oy) || (ox === player.x && oy === player.y) || (ox === goal.x && oy === goal.y)) continue;
        obstacles.push({ x: ox, y: oy });
      }

      const enemyCount = Math.floor(Math.random() * (MAX_ENEMIES - MIN_ENEMIES + 1)) + MIN_ENEMIES;
      tries = 0;
      while (staticEnemies.length < enemyCount && tries < 500) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if (
          (ex === player.x && ey === player.y) ||
          (ex === goal.x && ey === goal.y) ||
          isObstacle(ex, ey) ||
          isNearGoal(ex, ey) ||
          staticEnemies.some(e => e.x === ex && e.y === ey)
        ) continue;
        staticEnemies.push({ x: ex, y: ey });
      }

      const powerupCount = 3;
      tries = 0;
      while (powerups.length < powerupCount && tries < 1000) {
        tries++;
        const px = Math.floor(Math.random() * width);
        const py = Math.floor(Math.random() * height);
        if (
          isNearGoal(px, py) ||
          (px === player.x && py === player.y) ||
          (px === goal.x && py === goal.y) ||
          isObstacle(px, py) ||
          isStaticEnemy(px, py)
        ) continue;
        powerups.push({ x: px, y: py });
      }
    }

    function generateMaze() {
      mazeGrid = [];
      for (let y = 0; y < height; y++) {
        mazeGrid[y] = [];
        for (let x = 0; x < width; x++) mazeGrid[y][x] = 0;
      }

      function inBounds(x, y) { return x > 0 && x < width - 1 && y > 0 && y < height - 1; }

      let stack = [];
      let startX = 1, startY = 1;
      mazeGrid[startY][startX] = 1;
      stack.push({ x: startX, y: startY });

      const dirs = [
        { dx: 0, dy: -2 },
        { dx: 2, dy: 0 },
        { dx: 0, dy: 2 },
        { dx: -2, dy: 0 }
      ];

      while (stack.length > 0) {
        let current = stack[stack.length - 1];
        let neighbors = [];

        for (let i = 0; i < dirs.length; i++) {
          let nx = current.x + dirs[i].dx;
          let ny = current.y + dirs[i].dy;
          if (inBounds(nx, ny) && mazeGrid[ny][nx] === 0) neighbors.push({ x: nx, y: ny, dir: dirs[i] });
        }

        if (neighbors.length === 0) {
          stack.pop();
        } else {
          let next = neighbors[Math.floor(Math.random() * neighbors.length)];
          let wx = current.x + next.dir.dx / 2;
          let wy = current.y + next.dir.dy / 2;
          mazeGrid[wy][wx] = 1;
          mazeGrid[next.y][next.x] = 1;
          stack.push({ x: next.x, y: next.y });
        }
      }

      mazeGrid[player.y][player.x] = 1;

      let bestDist = 0;
      let bestGoal = { x: width - 2, y: height - 2 };
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          if (mazeGrid[y][x] === 1) {
            let dist = Math.abs(x - player.x) + Math.abs(y - player.y);
            if (dist > bestDist) { bestDist = dist; bestGoal = { x, y }; }
          }
        }
      }
      goal.x = bestGoal.x;
      goal.y = bestGoal.y;
    }

    const HAZARD_SPAWN_EVERY_MS = 2000;
    const HAZARD_WARN_MS = 1200;
    const HAZARD_BOOM_MS = 700;
    const HAZARD_TICK_MS = 100;

    function getHazardAt(x, y) {
      return hazards.find(h => h.x === x && h.y === y) || null;
    }
    function isHazardAny(x, y) { return !!getHazardAt(x, y); }
    function isHazardBoom(x, y) {
      const h = getHazardAt(x, y);
      return !!h && h.state === 'boom';
    }
    function cleanupHazards() {
      hazards = hazards.filter(h => h.t < (HAZARD_WARN_MS + HAZARD_BOOM_MS));
    }

    function spawnHazardMarkers() {
      if (!running || !gameStarted || paused) return;

      const count = Math.floor(Math.random() * 130) + 120;
      let placed = 0;
      let tries = 0;

      while (placed < count && tries < 3000) {
        tries++;
        if (hazards.length >= 60) break;

        const x = Math.floor(Math.random() * width);
        const y = Math.floor(Math.random() * height);

        if (x === player.x && y === player.y) continue;
        if (x === goal.x && y === goal.y) continue;
        if (isHazardAny(x, y)) continue;

        hazards.push({ x, y, state: 'warn', t: 0 });
        placed++;
      }

      drawGrid();
    }

    function tickHazards() {
      if (!running || !gameStarted || paused) return;

      hazards.forEach(h => {
        h.t += HAZARD_TICK_MS;
        if (h.state === 'warn' && h.t >= HAZARD_WARN_MS) h.state = 'boom';
      });

      if (currentMode === 'danger' && isHazardBoom(player.x, player.y)) {
        gameOver("You got blasted!");
        return;
      }

      cleanupHazards();
      drawGrid();
    }

    function startDangerSystem() {
      hazards = [];
      clearInterval(hazardSpawnInterval);
      clearInterval(hazardTickInterval);
      hazardSpawnInterval = setInterval(spawnHazardMarkers, HAZARD_SPAWN_EVERY_MS);
      hazardTickInterval = setInterval(tickHazards, HAZARD_TICK_MS);
    }

    function placeGoal() {
      if (currentMode === 'maze') return;

      do {
        goal.x = Math.floor(Math.random() * width);
        goal.y = Math.floor(Math.random() * height);
      } while (
        (currentMode === 'snake' && isSnakeCell(goal.x, goal.y)) ||
        (currentMode !== 'snake' && (goal.x === player.x && goal.y === player.y)) ||
        (goal.x === 0) ||
        (currentMode === 'grad' && (isObstacle(goal.x, goal.y) || isStaticEnemy(goal.x, goal.y) || isPowerup(goal.x, goal.y))) ||
        (currentMode === 'danger' && isHazardAny(goal.x, goal.y))
      );
    }

    function drawGrid() {
      gameDiv.innerHTML = '';
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          const hz = getHazardAt(x, y);

          if (currentMode === 'snake') {
            if (isSnakeHead(x, y)) {
              cell.innerHTML = '<span class="black">./</span>';
            }
            else if (isSnakeCell(x, y)) {
              cell.innerHTML = '<span class="black">/</span>';
            }
            else if (goal.x === x && goal.y === y) {
              cell.innerHTML = '<span class="black">./</span>';
            }
            else {
              cell.innerHTML = '&nbsp;';
            }

            gameDiv.appendChild(cell);
            continue;
          }

          if (player.x === x && player.y === y) {
            cell.innerHTML = '<span class="black">.</span>';
          }
          else if ((currentMode === 'grad' || currentMode === 'classic' || currentMode === 'maze' || currentMode === 'danger') && goal.x === x && goal.y === y) {
            cell.innerHTML = '<span class="black">/</span>';
          }
          else if (currentMode === 'survival' && isSurvivalEnemy(x, y)) {
            cell.innerHTML = '<span class="black">/</span>';
          }
          else if (currentMode === 'grad' && isStaticEnemy(x, y)) {
            cell.innerHTML = '<span class="black">,</span>';
          }
          else if (currentMode === 'grad' && isObstacle(x, y)) {
            cell.innerHTML = '<span class="black">-</span>';
          }
          else if (currentMode === 'grad' && isPowerup(x, y)) {
            cell.innerHTML = '<span class="black">*</span>';
          }
          else if (currentMode === 'maze') {
            if (mazeGrid[y] && mazeGrid[y][x] === 0) cell.innerHTML = '<span class="black">#</span>';
            else cell.innerHTML = '&nbsp;';
          }
          else if (currentMode === 'danger' && hz) {
            if (hz.state === 'warn') cell.innerHTML = '<span class="warn">x</span>';
            else cell.innerHTML = '<span class="boom">X</span>';
          }
          else {
            cell.innerHTML = '&nbsp;';
          }

          gameDiv.appendChild(cell);
        }
      }
    }

    function startTimer() {
      clearInterval(interval);
      timerSpan.textContent = time;
      interval = setInterval(() => {
        if (!paused) {
          time--;
          if (time <= 0) {
            time = 0;
            timerSpan.textContent = 0;
            clearInterval(interval);
            running = false;
            if (currentMode === 'survival') setTimeout(victory, 300);
            else setTimeout(gameOver, 300);
          } else {
            timerSpan.textContent = time;
          }
        }
      }, 1000);
    }

    function gameOver(msg = "Time is up!") {
      gameStarted = false;
      running = false;

      clearAllIntervals();

      const highscoreKey =
        currentMode === 'grad' ? 'gradHighScore' :
        currentMode === 'classic' ? 'classicHighScore' :
        currentMode === 'maze' ? 'mazeHighScore' :
        currentMode === 'danger' ? 'dangerHighScore' :
        currentMode === 'snake' ? 'snakeHighScore' :
        'survivalHighScore';

      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }

      highscoreSpan.textContent = highscore;
      highscoreTop.textContent = highscore;
      gameOverMsg.textContent = msg;
      finalscore.textContent = score;

      uiDiv.classList.add('hide');
      gameoverDiv.classList.remove('hide');
      pauseOverlay.style.display = 'none';
    }

    function victory() {
      gameStarted = false;
      running = false;

      clearAllIntervals();

      score = 100;
      const highscoreKey = 'survivalHighScore';
      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }
      victoryscore.textContent = score;
      victoryhighscore.textContent = highscore;
      highscoreTop.textContent = highscore;

      uiDiv.classList.add('hide');
      victoryDiv.classList.remove('hide');
      pauseOverlay.style.display = 'none';
    }

    function movePlayer(dx, dy) {
      if (!running || !gameStarted || paused) return;
      if (currentMode === 'snake') return; 

      let newX = player.x + dx;
      let newY = player.y + dy;

      if (currentMode === 'maze') {
        if (newX < 0 || newX >= width || newY < 0 || newY >= height) return;
        if (mazeGrid[newY][newX] === 0) return;
      } else {
        newX = (newX + width) % width;
        newY = (newY + height) % height;
      }

      if (currentMode !== 'maze' && currentMode !== 'survival') {
        const isTryingToEnterGoal = (newX === goal.x && newY === goal.y);
        const canEnterFromRight = (dx === 1);
        if (isTryingToEnterGoal && !canEnterFromRight) {
          return;
        }
      }

      if (currentMode === 'survival' && isSurvivalEnemy(newX, newY)) {
        gameOver("Enemy too close!");
        return;
      }

      if (currentMode === 'grad') {
        if (isObstacle(newX, newY)) return;
        if (isStaticEnemy(newX, newY)) {
          gameOver("You bumped into an opponent (,)");
          return;
        }
        if (isPowerup(newX, newY)) {
          score += 5;
          addTime(3);
          showPlusTime(newX, newY, './ +3 sec +5 points');
          const idx = powerups.findIndex(p => p.x === newX && p.y === newY);
          if (idx !== -1) powerups.splice(idx, 1);
          player.x = newX;
          player.y = newY;
          scoreSpan.textContent = score;
          drawGrid();
          return;
        }
      }

      if (currentMode === 'danger') {
        if (isHazardBoom(newX, newY)) {
          player.x = newX;
          player.y = newY;
          drawGrid();
          gameOver("You stepped into a blast!");
          return;
        }
      }

      const isMazeMode = currentMode === 'maze';
      const goalActivationCondition = isMazeMode
        ? (newX === goal.x && newY === goal.y)
        : (newX === goal.x && newY === goal.y && dx === 1);

      if (currentMode !== 'survival' && goalActivationCondition) {
        player.x = newX;
        player.y = newY;

        score++;
        scoreSpan.textContent = score;

        if (currentMode === 'maze') {
          addTime(20);
          showPlusTime(newX, newY, './ +20 sec');
          generateMaze();
        } else {
          addTime(2);
          showPlusTime(newX, newY, './ +2 sec');
          placeGoal();
          if (currentMode === 'grad') generateFullMode();
        }

        drawGrid();
        return;
      }

      player.x = newX;
      player.y = newY;

      if (currentMode === 'danger' && isHazardBoom(player.x, player.y)) {
        drawGrid();
        gameOver("You got blasted!");
        return;
      }

      drawGrid();
    }

    function resetSnakeMode() {
      snake = [
        { x: 15, y: 10 },
        { x: 14, y: 10 },
        { x: 13, y: 10 }
      ];
      snakeDir = { dx: 1, dy: 0 };
      snakeNextDir = { dx: 1, dy: 0 };

      goal = { x: 0, y: 0 };
      placeGoal();
    }

    function setSnakeDirection(dx, dy) {
      if (dx === -snakeDir.dx && dy === -snakeDir.dy) return;
      snakeNextDir = { dx, dy };
    }

    function snakeStep() {
      if (!running || !gameStarted || paused) return;
      if (currentMode !== 'snake') return;

      snakeDir = { ...snakeNextDir };

      const head = snake[0];
      const newHead = { x: head.x + snakeDir.dx, y: head.y + snakeDir.dy };

      if (newHead.x < 0 || newHead.x >= width || newHead.y < 0 || newHead.y >= height) {
        gameOver("Snake hit the wall!");
        return;
      }

      if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) {
        gameOver("Snake hit itself!");
        return;
      }

      const ate = (newHead.x === goal.x && newHead.y === goal.y);

      snake.unshift(newHead);

      if (ate) {
        score += 1;
        scoreSpan.textContent = score;

        placeGoal(); 
      } else {
        snake.pop();
      }

      drawGrid();
    }

    function startSnakeSystem() {
      clearInterval(snakeTickInterval);
      const speedMs = 120;
      snakeTickInterval = setInterval(snakeStep, speedMs);
    }

    function startGame(mode) {
      currentMode = mode;

      player = { x: 15, y: 10 };
      goal = { x: 0, y: 0 };
      score = 0;
      time = getInitialTime(mode);

      running = true;
      gameStarted = true;
      paused = false;

      scoreSpan.textContent = '0';
      timerSpan.textContent = time;

      clearAllIntervals();

      obstacles = []; staticEnemies = []; powerups = [];
      enemies = [];
      hazards = [];
      mazeGrid = [];

      snake = [];
      snakeDir = { dx: 1, dy: 0 };
      snakeNextDir = { dx: 1, dy: 0 };

      if (mode === 'survival') {
        generateSurvivalEnemies();
        survivalEnemiesMoveInterval = setInterval(() => {
          if (running && !paused) moveSurvivalEnemies();
        }, 1000);
      }
      else if (mode === 'maze') {
        player = { x: 1, y: 1 };
        generateMaze();
      }
      else if (mode === 'grad') {
        placeGoal();
        generateFullMode();
      }
      else if (mode === 'classic') {
        placeGoal();
        generateClassicMode();
      }
      else if (mode === 'danger') {
        placeGoal();
        startDangerSystem();
      }
      else if (mode === 'snake') {
        timerSpan.textContent = '--';
        resetSnakeMode();
        startSnakeSystem();
      }

      drawGrid();
      uiDiv.classList.remove('hide');
      welcomeDiv.classList.add('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';

      const highscoreKey =
        mode === 'grad' ? 'gradHighScore' :
        mode === 'classic' ? 'classicHighScore' :
        mode === 'maze' ? 'mazeHighScore' :
        mode === 'danger' ? 'dangerHighScore' :
        mode === 'snake' ? 'snakeHighScore' :
        'survivalHighScore';

      highscoreTop.textContent = localStorage.getItem(highscoreKey) || 0;

      if (mode !== 'snake') startTimer();
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'Space') e.preventDefault();

      if (e.code === 'Space' && gameStarted && running) {
        paused = !paused;
        pauseOverlay.style.display = paused ? 'flex' : 'none';
        return;
      }

      if (!running || !gameStarted || paused) return;

      if (currentMode === 'snake') {
        if (['ArrowUp','KeyW','KeyЦ'].includes(e.code)) setSnakeDirection(0, -1);
        if (['ArrowDown','KeyS','KeyЫ'].includes(e.code)) setSnakeDirection(0, 1);
        if (['ArrowLeft','KeyA','KeyФ'].includes(e.code)) setSnakeDirection(-1, 0);
        if (['ArrowRight','KeyD','KeyВ'].includes(e.code)) setSnakeDirection(1, 0);
        return;
      }

      if (['ArrowUp','KeyW','KeyЦ'].includes(e.code)) movePlayer(0, -1);
      if (['ArrowDown','KeyS','KeyЫ'].includes(e.code)) movePlayer(0, 1);
      if (['ArrowLeft','KeyA','KeyФ'].includes(e.code)) movePlayer(-1, 0);
      if (['ArrowRight','KeyD','KeyВ'].includes(e.code)) movePlayer(1, 0);
    });

    gradBtn.onclick = () => startGame('grad');
    classicBtn.onclick = () => startGame('classic');
    mazeBtn.onclick = () => startGame('maze');
    survivalBtn.onclick = () => startGame('survival');
    dangerBtn.onclick = () => startGame('danger');
    snakeBtn.onclick = () => startGame('snake');

    restartBtn.onclick = () => startGame(currentMode);
    restartBtnVictory.onclick = () => startGame(currentMode);

    menuBtn.onclick = showMenu;
    menuBtnGameover.onclick = showMenu;
    menuBtnVictory.onclick = showMenu;
  </script>
</body>
</html>
