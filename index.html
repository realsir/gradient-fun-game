<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>GradGame</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: monospace;
      min-height: 100vh;
      background: #ededed;
      overflow: hidden;
      position: relative; 
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    #bgtext {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      width: 100vw; height: 100vh;
      font-size: 22px;
      line-height: 29px;
      color: #0b8a00;
      opacity: 0.15;
      white-space: pre;
      pointer-events: none;
      z-index: 0;
      user-select: none;
      background: none;
    }
    .overlay {
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
      z-index: 3;
      background: rgba(255,255,255,0.82);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    .overlay-block {
      background: #fff;
      border-radius: 16px;
      box-shadow: 0 4px 22px #3333;
      padding: 30px 32px;
      text-align: center;
      font-size: 20px;
      color: #181818;
      min-width: 320px;
      max-width: 95vw;
      max-height: 85vh;
      overflow-y: auto;
    }
    .big-btn {
      display: inline-block;
      margin: 8px 0;
      padding: 12px 45px;
      font-size: 20px;
      background: #222;
      color: #fafafa;
      border: none;
      border-radius: 7px;
      letter-spacing: 0.1em;
      box-shadow: 0 2px 18px #aaa2;
      cursor: pointer;
      transition: background 0.2s;
      font-family: monospace;
      font-weight: 700;
      width: 100%;
      max-width: 280px;
    }
    .big-btn:hover, .big-btn:focus {
      background: #111;
    }
    .mode-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    .mode-card {
      background: rgba(255,255,255,0.7);
      border-radius: 12px;
      padding: 20px 15px;
      border: 2px solid #e0e0e0;
      transition: all 0.2s;
    }
    .mode-card:hover {
      border-color: #0b8a00;
      box-shadow: 0 4px 15px #0b8a0080;
    }
    .mode-desc {
      color: #555;
      font-size: 15px;
      line-height: 1.4;
      margin: 0;
    }
    #ui { 
      z-index: 1;
      position: relative;
      align-items: center;
      display: flex;
      flex-direction: column;
      margin-top: 10px;
    }
    .ui-top-row {
      display: flex;
      gap: 15px;
      align-items: center;
      margin-bottom: 10px;
    }
    #stats {
      font-size: 20px;
      background: #fffde6ee;
      padding: 5px 35px;
      border-radius: 10px;
      color: #1a1a1a;
      white-space: nowrap;
    }
    #menuBtn {
      padding: 5px 25px;
      font-size: 18px;
      background: #fffde6ee;
      color: #1a1a1a;
      border: 2px solid #ddd;
      border-radius: 10px;
      cursor: pointer;
      font-family: monospace;
      font-weight: 600;
      transition: all 0.2s;
      white-space: nowrap;
    }
    #menuBtn:hover {
      background: #fff;
      border-color: #bbb;
    }
    #gameContainer {
      position: relative;
      width: 720px;
      height: 480px;
      margin-bottom: 4px;
    }
    #game {
      display: grid;
      grid-template-columns: repeat(30, 24px);
      grid-template-rows: repeat(20, 24px);
      gap: 0;
      background: #fff;
      border: 2px solid #666;
      z-index: 1;
      position: absolute;
      top: 0;
      left: 0;
    }
    .cell {
      width: 24px; height: 24px;
      display: flex; align-items: center; justify-content: center;
      font-size: 21px;
      background: #fafafa;
      border: 1px solid #bbb;
      box-sizing: border-box;
      user-select: none;
      z-index: 2;
    }
    .black { color: #111 !important; font-weight: bold; }
    .hide { display: none !important; }

    .float-text {
      position: absolute;
      font-size: 18px;
      color: #0b8a00;
      font-weight: 700;
      pointer-events: none;
      z-index: 6;
      animation: floatUp 1.2s ease-out forwards;
    }
    @keyframes floatUp {
      0% {
        opacity: 1;
        transform: translate(-50%, 0) scale(1);
      }
      50% {
        transform: translate(-50%, -20px) scale(1.2);
      }
      100% {
        opacity: 0;
        transform: translate(-50%, -50px) scale(0.8);
      }
    }
    #pauseOverlay {
      position: fixed;
      z-index: 10;
      background: rgba(11, 138, 0, 0.7);
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      color: #fff;
      font-weight: 700;
      user-select: none;
      font-family: monospace;
      letter-spacing: 0.2em;
    }
  </style>
</head>
<body>
  <div id="bgtext"></div>
  
  <div id="welcome" class="overlay">
    <div class="overlay-block">
      <div style="font-size:25px;font-weight:700;margin-bottom:17px;">./ Welcome to "GradGame"</div>
      
      <div style="margin-bottom: 25px;">
        <div>Choose your game mode:</div>
      </div>
      
      <div class="mode-grid">
        <div class="mode-card">
          <button class="big-btn" id="gradBtn">./ GRAD MODE+</button>
          <div class="mode-desc">
            Single goal – collect combinations quickly!<br>
            • "-" advantages<br>
            • "," opponents (avoid)<br>
            • "./" +2 sec per combo<br>
            • "*" +5 points +3 sec<br>
            • SPACE pause
          </div>
        </div>
        
        <div class="mode-card">
          <button class="big-btn" id="classicBtn">./ GRAD CLASSIC</button>
          <div class="mode-desc">
            You (.) vs opponent (/) classic style.<br>
            • "./" activation only from right<br>
            • SPACE pause/unpause
          </div>
        </div>
        
        <div class="mode-card">
          <button class="big-btn" id="mazeBtn">./ GRAD MAZE</button>
          <div class="mode-desc">
            Navigate maze corridors to reach (/).<br>
            • "#" walls block movement<br>
            • Reach goal ANY side: +20 sec, new maze!<br>
            • 60 sec start time<br>
            • SPACE pause
          </div>
        </div>

        <div class="mode-card">
          <button class="big-btn" id="survivalBtn">./ GRAD SURVIVAL</button>
          <div class="mode-desc">
            Survive 30 sec vs 15 enemies (/).<br>
            • Enemies chase every second<br>
            • Game Over if adjacent!<br>
            • SPACE pause
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <div id="gameover" class="overlay hide">
    <div class="overlay-block" id="overmsg">
      <div style="font-size:23px;margin-bottom:14px;" id="gameOverMsg">Time is up!</div>
      Your score: <span id="finalscore"></span><br>
      High score: <span id="highscore"></span>
      <br />
      <div style="display:flex;gap:15px;justify-content:center;margin-top:20px;">
        <button class="big-btn" id="restartBtn" style="width:auto;">./ Restart</button>
        <button class="big-btn" id="menuBtnGameover" style="width:auto;">./ Menu</button>
      </div>
    </div>
  </div>
  
  <div id="victory" class="overlay hide">
    <div class="overlay-block" id="victorymsg">
      <div style="font-size:23px;margin-bottom:14px;color:#0b8a00;">./ YOU WIN!</div>
      Survival time: <span id="victoryscore"></span><br>
      Best survival: <span id="victoryhighscore"></span>
      <br />
      <div style="display:flex;gap:15px;justify-content:center;margin-top:20px;">
        <button class="big-btn" id="restartBtnVictory" style="width:auto;">./ Restart</button>
        <button class="big-btn" id="menuBtnVictory" style="width:auto;">./ Menu</button>
      </div>
    </div>
  </div>
  
  <div id="pauseOverlay">./ PAUSED</div>
  
  <div id="ui" class="hide">
    <div class="ui-top-row">
      <button id="menuBtn">./ Menu</button>
      <div id="stats">
        Score: <span id="score">0</span> | Time: <span id="timer">60</span> sec | High score: <span id="highscoreTop">0</span>
      </div>
    </div>
    <div id="gameContainer">
      <div id="game"></div>
    </div>
  </div>

  <script>
    function fillBgText() {
      let rows = Math.ceil(window.innerHeight / 29) + 2;
      let cols = Math.ceil(window.innerWidth / 18);
      let str = '';
      let line = '';
      let pattern = './ GradGame ';
      for(let i = 0; i < Math.ceil(cols * 1.5); i++) line += pattern;
      for(let i = 0; i < rows; i++) str += line.substr(0, cols*9) + '\n'; 
      document.getElementById("bgtext").textContent = str;
    }
    window.addEventListener('resize', fillBgText);
    fillBgText();

    const width = 30, height = 20;
    let player, goal, score, time, interval, running, gameStarted = false, paused = false, currentMode = '';
    let enemies = [], survivalEnemiesMoveInterval;

    const gameContainer = document.getElementById('gameContainer');
    const gameDiv = document.getElementById('game');
    const scoreSpan = document.getElementById('score');
    const timerSpan = document.getElementById('timer');
    const uiDiv = document.getElementById('ui');
    const welcomeDiv = document.getElementById('welcome');
    const gameoverDiv = document.getElementById('gameover');
    const victoryDiv = document.getElementById('victory');
    const finalscore = document.getElementById('finalscore');
    const victoryscore = document.getElementById('victoryscore');
    const highscoreSpan = document.getElementById('highscore');
    const highscoreTop = document.getElementById('highscoreTop');
    const victoryhighscore = document.getElementById('victoryhighscore');
    const pauseOverlay = document.getElementById('pauseOverlay');
    const menuBtn = document.getElementById('menuBtn');
    const menuBtnGameover = document.getElementById('menuBtnGameover');
    const menuBtnVictory = document.getElementById('menuBtnVictory');
    const gradBtn = document.getElementById('gradBtn');
    const classicBtn = document.getElementById('classicBtn');
    const survivalBtn = document.getElementById('survivalBtn');
    const restartBtn = document.getElementById('restartBtn');
    const restartBtnVictory = document.getElementById('restartBtnVictory');
    const gameOverMsg = document.getElementById('gameOverMsg');
    const mazeBtn = document.getElementById('mazeBtn');

    let obstacles = [], powerups = [], staticEnemies = [];
    let mazeGrid = []; // 0 - стена, 1 - проход

    function getInitialTime(mode) {
      return mode === 'maze' ? 60 : 30;
    }

    function showMenu() {
      gameStarted = false;
      running = false;
      paused = false;
      clearInterval(interval);
      clearInterval(survivalEnemiesMoveInterval);
      uiDiv.classList.add('hide');
      welcomeDiv.classList.remove('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';
      gameDiv.innerHTML = '';
    }

    function isObstacle(x, y) {
      return obstacles.some(o => o.x === x && o.y === y);
    }

    function isStaticEnemy(x, y) {
      return staticEnemies.some(e => e.x === x && e.y === y);
    }

    function isPowerup(x, y) {
      return powerups.some(p => p.x === x && p.y === y);
    }

    function isSurvivalEnemy(x, y) {
      return enemies.some(e => e.x === x && e.y === y);
    }

    function isPositionOccupied(x, y) {
      return (x === player.x && y === player.y) || isSurvivalEnemy(x, y);
    }

    function isEnemyAdjacentToPlayer() {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue; 
          let checkX = (player.x + dx + width) % width;
          let checkY = (player.y + dy + height) % height;
          if (isSurvivalEnemy(checkX, checkY)) {
            return true;
          }
        }
      }
      return false;
    }

    function generateSurvivalEnemies() {
      enemies = [];
      let tries = 0;
      while (enemies.length < 15 && tries < 1000) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if (isPositionOccupied(ex, ey) || enemies.some(e => e.x === ex && e.y === ey)) continue;
        enemies.push({x: ex, y: ey});
      }
    }

    function generateFullMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];
      
      const MIN_OBS = 20, MAX_OBS = 30;
      const MIN_ENEMIES = 3, MAX_ENEMIES = 5;

      const obsCount = Math.floor(Math.random() * (MAX_OBS - MIN_OBS + 1)) + MIN_OBS;
      let tries = 0;
      while (obstacles.length < obsCount && tries < 1000) {
        tries++;
        const ox = Math.floor(Math.random() * width);
        const oy = Math.floor(Math.random() * height);
        if (isNearGoal(ox, oy) || (ox === player.x && oy === player.y) || (ox === goal.x && oy === goal.y)) continue;
        obstacles.push({x: ox, y: oy});
      }

      const enemyCount = Math.floor(Math.random() * (MAX_ENEMIES - MIN_ENEMIES + 1)) + MIN_ENEMIES;
      tries = 0;
      while (staticEnemies.length < enemyCount && tries < 500) {
        tries++;
        const ex = Math.floor(Math.random() * width);
        const ey = Math.floor(Math.random() * height);
        if (
          (ex === player.x && ey === player.y) ||
          (ex === goal.x && ey === goal.y) ||
          isObstacle(ex, ey) ||
          isNearGoal(ex, ey) ||
          staticEnemies.some(e => e.x === ex && e.y === ey)
        ) continue;
        staticEnemies.push({x: ex, y: ey});
      }

      const powerupCount = 3;
      tries = 0;
      while (powerups.length < powerupCount && tries < 1000) {
        tries++;
        const px = Math.floor(Math.random() * width);
        const py = Math.floor(Math.random() * height);
        if (
          isNearGoal(px, py) || 
          (px === player.x && py === player.y) || 
          (px === goal.x && py === goal.y) ||
          isObstacle(px, py) ||
          isStaticEnemy(px, py)
        ) continue;
        powerups.push({x: px, y: py});
      }
    }

    function moveSurvivalEnemies() {
      if (isEnemyAdjacentToPlayer()) {
        gameOver("Enemy too close!");
        return;
      }

      let movedEnemies = [];
      enemies.forEach(enemy => {
        let bestDx = 0, bestDy = 0, bestDist = Infinity;
        
        for (let dx = -1; dx <= 1; dx++) {
          for (let dy = -1; dy <= 1; dy++) {
            if (dx === 0 && dy === 0) continue;
            let nx = (enemy.x + dx + width) % width;
            let ny = (enemy.y + dy + height) % height;
            
            let occupied = isPositionOccupied(nx, ny) || 
                          movedEnemies.some(m => m.x === nx && m.y === ny);
            
            let dist = Math.abs(nx - player.x) + Math.abs(ny - player.y);
            if (!occupied && dist < bestDist) {
              bestDist = dist;
              bestDx = dx;
              bestDy = dy;
            }
          }
        }
        
        let newX = (enemy.x + bestDx + width) % width;
        let newY = (enemy.y + bestDy + height) % height;
        enemy.x = newX;
        enemy.y = newY;
        movedEnemies.push({x: newX, y: newY});
      });
      
      if (isEnemyAdjacentToPlayer()) {
        gameOver("Enemy too close!");
      } else {
        drawGrid();
      }
    }

    function generateClassicMode() {
      obstacles = [];
      staticEnemies = [];
      powerups = [];
    }

    function isNearGoal(x, y) {
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (goal.x + dx === x && goal.y + dy === y) return true;
        }
      }
      return false;
    }

    function generateMaze() {
      mazeGrid = [];
      for (let y = 0; y < height; y++) {
        mazeGrid[y] = [];
        for (let x = 0; x < width; x++) {
          mazeGrid[y][x] = 0;
        }
      }

      function inBounds(x, y) {
        return x > 0 && x < width - 1 && y > 0 && y < height - 1;
      }

      let stack = [];
      let startX = 1;
      let startY = 1;
      mazeGrid[startY][startX] = 1;
      stack.push({x: startX, y: startY});

      const dirs = [
        {dx: 0, dy: -2},
        {dx: 2, dy: 0},
        {dx: 0, dy: 2},
        {dx: -2, dy: 0}
      ];

      while (stack.length > 0) {
        let current = stack[stack.length - 1];
        let neighbors = [];

        for (let i = 0; i < dirs.length; i++) {
          let nx = current.x + dirs[i].dx;
          let ny = current.y + dirs[i].dy;
          if (inBounds(nx, ny) && mazeGrid[ny][nx] === 0) {
            neighbors.push({x: nx, y: ny, dir: dirs[i]});
          }
        }

        if (neighbors.length === 0) {
          stack.pop();
        } else {
          let next = neighbors[Math.floor(Math.random() * neighbors.length)];
          let wx = current.x + next.dir.dx / 2;
          let wy = current.y + next.dir.dy / 2;
          mazeGrid[wy][wx] = 1;
          mazeGrid[next.y][next.x] = 1;
          stack.push({x: next.x, y: next.y});
        }
      }

      mazeGrid[player.y][player.x] = 1;

      let bestDist = 0;
      let bestGoal = {x: width - 2, y: height - 2};
      
      for (let y = 1; y < height - 1; y++) {
        for (let x = 1; x < width - 1; x++) {
          if (mazeGrid[y][x] === 1) {
            let dist = Math.abs(x - player.x) + Math.abs(y - player.y);
            if (dist > bestDist) {
              bestDist = dist;
              bestGoal = {x, y};
            }
          }
        }
      }
      goal.x = bestGoal.x;
      goal.y = bestGoal.y;
    }

    function drawGrid() {
      gameDiv.innerHTML = '';
      for(let y = 0; y < height; y++) {
        for(let x = 0; x < width; x++) {
          const cell = document.createElement('div');
          cell.className = 'cell';

          if (player.x === x && player.y === y) {
            cell.innerHTML = '<span class="black">.</span>';
          }
          else if ((currentMode === 'grad' || currentMode === 'classic' || currentMode === 'maze') && goal.x === x && goal.y === y) {
            cell.innerHTML = '<span class="black">/</span>';
          }
          else if (currentMode === 'survival' && isSurvivalEnemy(x, y)) {
            cell.innerHTML = '<span class="black">/</span>';
          }
          else if (currentMode === 'grad' && isStaticEnemy(x, y)) {
            cell.innerHTML = '<span class="black">,</span>';
          } else if (currentMode === 'grad' && isObstacle(x, y)) {
            cell.innerHTML = '<span class="black">-</span>';
          } else if (currentMode === 'grad' && isPowerup(x, y)) {
            cell.innerHTML = '<span class="black">*</span>';
          }
          else if (currentMode === 'maze') {
            if (mazeGrid[y] && mazeGrid[y][x] === 0) {
              cell.innerHTML = '<span class="black">#</span>';
            } else {
              cell.innerHTML = '&nbsp;';
            }
          }
          else {
            cell.innerHTML = '&nbsp;';
          }

          gameDiv.appendChild(cell);
        }
      }
    }

    function placeGoal() {
      if (currentMode === 'maze') return;
      do {
        goal.x = Math.floor(Math.random() * width);
        goal.y = Math.floor(Math.random() * height);
      } while (
        (goal.x === player.x && goal.y === player.y) ||
        (goal.x === 0) ||
        (currentMode === 'grad' && (isObstacle(goal.x, goal.y) || isStaticEnemy(goal.x, goal.y) || isPowerup(goal.x, goal.y)))
      );
    }

    function showPlusTime(x, y, text) {
      const float = document.createElement('div');
      float.className = 'float-text';
      float.textContent = text;
      const cellSize = 24;
      const offsetX = x * cellSize + cellSize / 2;
      const offsetY = y * cellSize + cellSize / 2;
      float.style.left = offsetX + 'px';
      float.style.top = offsetY + 'px';
      gameContainer.appendChild(float);
      setTimeout(() => {
        if (float.parentNode) float.parentNode.removeChild(float);
      }, 1300);
    }

    function addTime(seconds) {
      time += seconds;
      timerSpan.textContent = time;
    }

    function gameOver(msg = "Time is up!") {
      gameStarted = false;
      running = false;
      clearInterval(survivalEnemiesMoveInterval);
      const highscoreKey =
        currentMode === 'grad' ? 'gradHighScore' : 
        currentMode === 'classic' ? 'classicHighScore' :
        currentMode === 'maze' ? 'mazeHighScore' :
        'survivalHighScore';
      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }
      highscoreSpan.textContent = highscore;
      highscoreTop.textContent = highscore;
      gameOverMsg.textContent = msg;
      finalscore.textContent = score;
      uiDiv.classList.add('hide');
      gameoverDiv.classList.remove('hide');
    }

    function victory() {
      gameStarted = false;
      running = false;
      clearInterval(survivalEnemiesMoveInterval);
      score = 100;
      const highscoreKey = 'survivalHighScore';
      let highscore = localStorage.getItem(highscoreKey) || 0;
      if (score > highscore) {
        localStorage.setItem(highscoreKey, score);
        highscore = score;
      }
      victoryscore.textContent = score;
      victoryhighscore.textContent = highscore;
      highscoreTop.textContent = highscore;
      uiDiv.classList.add('hide');
      victoryDiv.classList.remove('hide');
    }

    function movePlayer(dx, dy) {
      if (!running || !gameStarted || paused) return;

      let newX = player.x + dx;
      let newY = player.y + dy;

      if (currentMode === 'maze') {
        if (newX < 0 || newX >= width || newY < 0 || newY >= height) {
          return;
        }
        if (mazeGrid[newY][newX] === 0) {
          return;
        }
      } else {
        newX = (newX + width) % width;
        newY = (newY + height) % height;
      }

      if (currentMode === 'survival' && isSurvivalEnemy(newX, newY)) {
        gameOver("Enemy too close!");
        return;
      }

      if (currentMode === 'grad') {
        if (isObstacle(newX, newY)) return;
        if (isStaticEnemy(newX, newY)) {
          gameOver("You bumped into an opponent (,)");
          return;
        }
        if (isPowerup(newX, newY)) {
          score += 5;
          addTime(3);
          showPlusTime(newX, newY, './ +3 sec +5 points');
          const idx = powerups.findIndex(p => p.x === newX && p.y === newY);
          if (idx !== -1) powerups.splice(idx, 1);
          player.x = newX;
          player.y = newY;
          scoreSpan.textContent = score;
          drawGrid();
          return;
        }
      }

      const isMazeMode = currentMode === 'maze';
      const goalActivationCondition = isMazeMode ? 
        (newX === goal.x && newY === goal.y) :  
        (newX === goal.x && newY === goal.y && dx === 1);  

      if (currentMode !== 'survival' && goalActivationCondition) {
        player.x = newX;
        player.y = newY;
        score++;
        scoreSpan.textContent = score;
        
        if (currentMode === 'maze') {
          addTime(20);
          showPlusTime(newX, newY, './ +20 sec');
          generateMaze(); 
        } else {
          addTime(2);
          showPlusTime(newX, newY, './ +2 sec');
          placeGoal();
          if (currentMode === 'grad') generateFullMode();
        }
        drawGrid();
        return;
      }

      player.x = newX;
      player.y = newY;
      drawGrid();
    }

    function startTimer() {
      clearInterval(interval);
      timerSpan.textContent = time;
      interval = setInterval(() => {
        if (!paused) {
          time--;
          if (time <= 0) {
            time = 0;
            timerSpan.textContent = 0;
            clearInterval(interval);
            running = false;
            if (currentMode === 'survival') {
              setTimeout(victory, 300);
            } else {
              setTimeout(gameOver, 300);
            }
          } else {
            timerSpan.textContent = time;
          }
        }
      }, 1000);
    }

    function startGame(mode) {
      currentMode = mode;
      player = {x: 1, y: 1};
      goal = {x: 0, y: 0};
      score = 0;
      time = getInitialTime(mode);
      running = true;
      gameStarted = true;
      paused = false;
      
      scoreSpan.textContent = '0';
      timerSpan.textContent = time;
      
      if (mode === 'survival') {
        player = {x: 15, y: 10};
        generateSurvivalEnemies();
        clearInterval(survivalEnemiesMoveInterval);
        survivalEnemiesMoveInterval = setInterval(() => {
          if (running && !paused) {
            moveSurvivalEnemies();
          }
        }, 1000);
      } else if (mode === 'maze') {
        obstacles = [];
        staticEnemies = [];
        powerups = [];
        generateMaze();
      } else {
        player = {x: 15, y: 10};
        clearInterval(survivalEnemiesMoveInterval);
        placeGoal();
        if (mode === 'grad') {
          generateFullMode();
        } else {
          generateClassicMode();
        }
      }
      
      drawGrid();
      uiDiv.classList.remove('hide');
      welcomeDiv.classList.add('hide');
      gameoverDiv.classList.add('hide');
      victoryDiv.classList.add('hide');
      pauseOverlay.style.display = 'none';
      
      const highscoreKey =
        mode === 'grad' ? 'gradHighScore' : 
        mode === 'classic' ? 'classicHighScore' :
        mode === 'maze' ? 'mazeHighScore' :
        'survivalHighScore';
      highscoreTop.textContent = localStorage.getItem(highscoreKey) || 0;
      
      startTimer();
    }

    document.addEventListener('keydown', e => {
      if (e.code === 'Space') {
        e.preventDefault();
      }
      if (e.code === 'Space' && gameStarted && running) {
        paused = !paused;
        pauseOverlay.style.display = paused ? 'flex' : 'none';
        return;
      }
      if (!running || !gameStarted || paused) return;
      if (['ArrowUp','KeyW','KeyЦ'].includes(e.code)) movePlayer(0, -1);
      if (['ArrowDown','KeyS','KeyЫ'].includes(e.code)) movePlayer(0, 1);
      if (['ArrowLeft','KeyA','KeyФ'].includes(e.code)) movePlayer(-1, 0);
      if (['ArrowRight','KeyD','KeyВ'].includes(e.code)) movePlayer(1, 0);
    });

    gradBtn.onclick = () => startGame('grad');
    classicBtn.onclick = () => startGame('classic');
    mazeBtn.onclick = () => startGame('maze');
    survivalBtn.onclick = () => startGame('survival');
    restartBtn.onclick = () => startGame(currentMode);
    restartBtnVictory.onclick = () => startGame(currentMode);
    menuBtn.onclick = showMenu;
    menuBtnGameover.onclick = showMenu;
    menuBtnVictory.onclick = showMenu;
  </script>
</body>
</html>

